<!DOCTYPE html>
<html lang="en">
<body style="overflow: hidden; margin:0">
<canvas id="myCanvas"\>
<script>
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");
const width = canvas.width = window.innerWidth;
const height = canvas.height = window.innerHeight;
var data = ctx.createImageData(width, height);
var buf = new Uint32Array(data.data.buffer);
buf.forEach((_, i) => buf[i] = "0xFF" + ["f0f6f2", "fdbea4", "ae3d28", "3d0704", "839392"][~~(Math.random() * 5)])
const DIRECTIONS = [-width, -width + 1, 1, width + 1, width, width - 1, -1, -width - 1];
const PIXEL_LIST = buf.map((_, i) => i).sort(() => Math.random() - 0.5);
const MAX_COLORS = 4;
const CHUNK_SIZE = 4;

const img = new Image();
img.crossOrigin="anonymous";
img.src = "car.jpg";

img.onload = () => {
  	ctx.drawImage(img, 0, 0, width, height);
	data = ctx.getImageData(0, 0, width, height);
	buf = new Uint32Array(data.data.buffer);

	interpolateFarthest()
	console.log(buf.length);
	while(PALLET.length < MAX_COLORS){
		addSplit()
	}
	PIXEL_LIST.forEach(pixel => buf[pixel] = getClosestColor(buf[pixel]))
	console.log(PALLET.length)
	chunk()
	compress()
	ctx.putImageData(data,0,0);
};


var PALLET = []// = Array(MAX_COLORS).fill().map(() => ~~(Math.random() * 0xFFFFFF) + 0xFF000000);
const MAX_DISTANCE = 196608;
const THRESHOLD = 2000;
function getClosestColor(c1){
	var returnColor = 0;
	var distance = -1;
	PALLET.forEach(c2 => {
		var cDistance = getDistance(c1, c2);
		if(cDistance < distance || distance < 0){
			distance = cDistance;
			returnColor = c2;
		}
	});

	return returnColor;
}

function interpolateFarthest(){
	[c1, c2] = farthestColors(PIXEL_LIST.slice(0, 1000).map(pixel => buf[pixel]));
	const r1 = (c1 >> 16) & 0xFF; 
  	const g1 = (c1 >> 8) & 0xFF;
  	const b1 = c1 & 0xFF;
	const r2 = (c2 >> 16) & 0xFF; 
  	const g2 = (c2 >> 8) & 0xFF;
  	const b2 = c2 & 0xFF;
	const rDistance = r2 - r1;
	const gDistance = g2 - g1;
	const bDistance = b2 - b1;
	for(let i = 0; i < MAX_COLORS; i++){
		//let c = i / (MAX_COLORS - 1)
		let c = (i + .5) / MAX_COLORS
		let r = Math.floor(r1 + (rDistance * c));
		let g = Math.floor(g1 + (gDistance * c));
		let b = Math.floor(b1 + (bDistance * c));
		PALLET.push((255 << 24 | (r << 16) | (g << 8) | b) >>> 0);
	}
	
}

function generatePallet(c1){
	var distance = MAX_DISTANCE;
	PALLET.forEach(c2 => {
		distance = Math.min(getDistance(c1, c2), distance);
	});

	if(!PALLET.length || (PALLET.length < MAX_COLORS && distance > THRESHOLD)){
		PALLET.push(c1);
	}
}

function farthestColors(colors){
	colors = [...new Set(colors)]
	console.log(colors.length);

	var c1, c2
	var distance = 0;

	for(var i = 0; i < colors.length; i++){
		var iColor = colors[i];
		for(var j = i + 1; j < colors.length; j++){
			var jColor = colors[j];
			let testDistance = getDistance(iColor, jColor);
			if(testDistance > distance){
				distance = testDistance;
				c1 = iColor;
				c2 = jColor;
			}
		}
	}
	
	return [c1, c2]
}

function addSplit(){
	if(PALLET.length){
		var colorMap = {}
		var randomStart = Math.floor(Math.random() * PIXEL_LIST.length)

		PALLET.forEach(p => colorMap[p] = [])
		for(var i = 0; i < 1000; i++){
			var c = buf[(i + randomStart) % PIXEL_LIST.length];
			var closest = 0;
			var distance = -1;
			PALLET.forEach(c2 => {
				var cDistance = getDistance(c, c2);
				if(cDistance < distance || distance < 0){
					distance = cDistance;
					closest = c2;
				}
			});

			colorMap[closest].push(c);
		}

		var count = -1;
		var color
		PALLET.forEach(p => {
			//colorMap[p] = [...new Set(colorMap[p])];
			if(colorMap[p].length > count){
				count = colorMap[p].length;
				color = p;
			}
		});

		PALLET = PALLET.filter(p => p != color)
		PALLET = PALLET.concat(farthestColors(colorMap[color]));
	}else{
		PALLET = farthestColors(PIXEL_LIST.slice(0, 1000).map(pixel => buf[pixel]));
	}
}

function getDistance(c1, c2){
	const r1 = (c1 >> 16) & 0xFF; 
  	const g1 = (c1 >> 8) & 0xFF;
  	const b1 = c1 & 0xFF;
	const r2 = (c2 >> 16) & 0xFF; 
  	const g2 = (c2 >> 8) & 0xFF;
  	const b2 = c2 & 0xFF;

	return Math.pow(r1-r2, 2) + Math.pow(g1-g2, 2) +  Math.pow(b1-b2, 2)
}

function chunk(){
	let chunkWidth = Math.ceil(width / CHUNK_SIZE);
	let chunkHeight = Math.ceil(height / CHUNK_SIZE);

	for(let i = 0; i < chunkWidth; i++){
		for(let j = 0; j < chunkHeight; j++){
			setChunkColor(i, j);
		}
	}

	console.log("OUTSIZE: " + chunkWidth * chunkHeight * 4 / 8)
}

function setChunkColor(w, h){
	let palletHist = {}
	PALLET.forEach(p => palletHist[p] = 0)
	let startW = w * CHUNK_SIZE;
	let startH = h * CHUNK_SIZE;
	for(let i = startW; i < startW + CHUNK_SIZE; i++){
		for(let j = startH; j < startH + CHUNK_SIZE; j++){
			if(i < width && j < height){
				let color = buf[width * j + i];
				palletHist[color]++
			}
		}
	}

	let count = -1;
	let color
	PALLET.forEach(p => {
		if(palletHist[p] > count){
			count = palletHist[p];
			color = p;
		}
	});
	
	for(let i = startW; i < startW + CHUNK_SIZE; i++){
		for(let j = startH; j < startH + CHUNK_SIZE; j++){
			if(i < width && j < height){
				buf[width * j + i] = color;
			}
		}
	}
}

function compress(){
	let counter = 0;
	let max = 32;
	let out = [];
	let color = 0;
	let chunkWidth = Math.ceil(width / CHUNK_SIZE);
	let chunkHeight = Math.ceil(height / CHUNK_SIZE);

	for(let i = 0; i < chunkWidth; i++){
		for(let j = 0; j < chunkHeight; j++){

			let index = (j * CHUNK_SIZE * width) + (i * CHUNK_SIZE)
			if(color != buf[index] || counter == max){
				out.push(color)
				color = buf[index]
				counter = 0;
			}
			counter++;

		}
	}
	console.log(chunkWidth*chunkHeight)
	console.log(out.length)
}
</script>
</body>
</html>