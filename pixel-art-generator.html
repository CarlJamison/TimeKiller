<!DOCTYPE html>
<html lang="en">
<body style="overflow: hidden; margin:0">
<canvas id="myCanvas"\>
<script>
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");
const width = canvas.width = window.innerWidth;
const height = canvas.height = window.innerHeight;
var data = ctx.createImageData(width, height);
var buf = new Uint32Array(data.data.buffer);
buf.forEach((_, i) => buf[i] = "0xFF" + ["f0f6f2", "fdbea4", "ae3d28", "3d0704", "839392"][~~(Math.random() * 5)])
const DIRECTIONS = [-width, -width + 1, 1, width + 1, width, width - 1, -1, -width - 1];
const PIXEL_LIST = buf.map((_, i) => i).sort(() => Math.random() - 0.5);
const MAX_COLORS = 3;
const CHUNK_SIZE = 5;

const img = new Image();
img.crossOrigin="anonymous";
img.src = "tree.jpg";
var distanceScore = 0;
img.onload = () => {
  	ctx.drawImage(img, 0, 0, width, height);
	data = ctx.getImageData(0, 0, width, height);
	buf = new Uint32Array(data.data.buffer);

	//convertToGrayScale();

	interpolateFarthest()
	//getRandomSample()
	console.log(buf.length);
	while(PALLET.length < MAX_COLORS){
		addSplit()
	}
	//PIXEL_LIST.forEach(pixel => generatePallet(buf[pixel]))
	//PALLET = Array(MAX_COLORS).fill().map(() => ~~(Math.random() * 0xFFFFFF) + 0xFF000000);
	tunePallet()
	PIXEL_LIST.forEach(pixel => buf[pixel] = getClosestColor(buf[pixel]))

	console.log("Score: " + (distanceScore / buf.length * 100))
	console.log(PALLET.length)
	//chunk()
	//compress()
	ctx.putImageData(data,0,0);
};


var PALLET = []// = Array(MAX_COLORS).fill().map(() => ~~(Math.random() * 0xFFFFFF) + 0xFF000000);
const MAX_DISTANCE = Math.sqrt(195075);
const THRESHOLD = 2000;
function getClosestColor(c1){
	var returnColor = 0;
	var distance = -1;
	PALLET.forEach(c2 => {
		var cDistance = getDistance(c1, c2);
		if(cDistance < distance || distance < 0){
			distance = cDistance;
			returnColor = c2;
		}
	});

	distanceScore += Math.sqrt(distance) / MAX_DISTANCE
	return returnColor;
}

function convertToGrayScale(){
	for(let i = 0; i < buf.length; i++){
		let c = buf[i]
		const r = (c >> 16) & 0xFF; 
		const g = (c >> 8) & 0xFF;
		const b = c & 0xFF;
		let v = Math.floor((r + g + b) / 3)
		buf[i] = ((255 << 24 | (v << 16) | (v << 8) | v) >>> 0);
	}
}

function getRandomPallet(){
	let bestPallet;
	let score = 0;

	for(let i = 0; i < 100; i++){
		let testPallet = Array(MAX_COLORS).fill().map(() => ~~(Math.random() * 0xFFFFFF) + 0xFF000000);
		let testScore = getScore(testPallet);
		if(testScore < score || !bestPallet){
			bestPallet = testPallet;
			score = testScore;
		}
		
		console.log("Running sample " + testScore)
	}

	PALLET = bestPallet;
}

function getRandomSample(){
	let bestPallet;
	let score = 0;
	
	const SAMPLE_LENGTH = 10000;
	const start = Math.floor((PIXEL_LIST.length - SAMPLE_LENGTH) * Math.random());
	let slice = PIXEL_LIST.slice(start, start + SAMPLE_LENGTH).map(p => buf[p]);

	for(let i = 0; i < 1000; i++){
		console.log("Running sample " + i)
		testPallet = []
		for(j = 0; j < MAX_COLORS; j++){
			testPallet.push(buf[Math.floor(Math.random() * buf.length)]);
		}

		let testScore = getSampleScore(testPallet, slice);
		if(testScore < score || !bestPallet){
			bestPallet = testPallet;
			score = testScore;
		}	
	}
	PALLET = bestPallet;
}

function getSampleScore(testPallet, slice){
	return slice.reduce((score, c1) => {
		const r1 = (c1 >> 16) & 0xFF; 
		const g1 = (c1 >> 8) & 0xFF;
		const b1 = c1 & 0xFF;
		return score + testPallet.reduce((distance, c2) => {
			const r2 = (c2 >> 16) & 0xFF; 
			const g2 = (c2 >> 8) & 0xFF;
			const b2 = c2 & 0xFF;
			let testDistance = Math.pow(r1-r2, 2) + Math.pow(g1-g2, 2) +  Math.pow(b1-b2, 2) 
		
			return Math.min(testDistance, distance);
		}, MAX_DISTANCE * MAX_DISTANCE);
	}, 0);
}

function tunePallet(){

	const SAMPLE_LENGTH = 1000;
	const start = Math.floor((PIXEL_LIST.length - SAMPLE_LENGTH) * Math.random());
	let slice = PIXEL_LIST.slice(start, start + SAMPLE_LENGTH).map(p => buf[p]);
	let baseScore = getSampleScore(PALLET, slice);
	console.log(baseScore)

	let changed = true;
	while(changed){
		changed = false;
		for(let i = 0; i < 3 * PALLET.length; i++){
			let index = Math.floor(i / 3);
			let slot = i % 3;
			let baseColor = PALLET[index];
			let val = baseColor >> (8 * slot) & 0xFF
			let direction = 0;
			let newScore = baseScore;
			let newColor = baseColor;
			
			let raisedColor = baseColor + Math.pow(2, 8 * slot);
			PALLET[index] = raisedColor;
			let raisedScore = getSampleScore(PALLET, slice);
			if(raisedScore < baseScore){
				direction = 1;
				newColor = raisedColor;
				newScore = raisedScore;
			}

			loweredColor = baseColor - Math.pow(2, 8 * slot);
			PALLET[index] = loweredColor;
			let loweredScore = getSampleScore(PALLET, slice);
			if(loweredScore < Math.min(baseScore, newScore)){
				direction = -1;
				newColor = loweredColor;
				newScore = loweredScore;
			}

			if(direction != 0){
				changed = true;
				while(newScore < baseScore){
					baseScore = newScore;
					baseColor = newColor;
					newColor = baseColor + (Math.pow(2, 8 * slot) * direction) 
					PALLET[index] = baseColor;
					newScore = getSampleScore(PALLET, slice);
				}
			}

			PALLET[index] = baseColor;
		}

		let newScore = getSampleScore(PALLET, slice);
		console.log(newScore)
	}
	//console.log(newScore - baseScore);

}

function getScore(testPallet){
	return buf.reduce((score, c1) => {
		const r1 = (c1 >> 16) & 0xFF; 
		const g1 = (c1 >> 8) & 0xFF;
		const b1 = c1 & 0xFF;
		return score + Math.sqrt(testPallet.reduce((distance, c2) => {
			const r2 = (c2 >> 16) & 0xFF; 
			const g2 = (c2 >> 8) & 0xFF;
			const b2 = c2 & 0xFF;
			let testDistance = Math.pow(r1-r2, 2) + Math.pow(g1-g2, 2) +  Math.pow(b1-b2, 2) 
		
			return Math.min(testDistance, distance);
		}, MAX_DISTANCE * MAX_DISTANCE));
	}, 0);
}

function interpolateFarthest(){
	[c1, c2] = farthestColors(PIXEL_LIST.slice(0, 1000).map(pixel => buf[pixel]));
	const r1 = (c1 >> 16) & 0xFF; 
  	const g1 = (c1 >> 8) & 0xFF;
  	const b1 = c1 & 0xFF;
	const r2 = (c2 >> 16) & 0xFF; 
  	const g2 = (c2 >> 8) & 0xFF;
  	const b2 = c2 & 0xFF;
	const rDistance = r2 - r1;
	const gDistance = g2 - g1;
	const bDistance = b2 - b1;
	for(let i = 0; i < MAX_COLORS; i++){
		let c = (i + .5) / MAX_COLORS
		let r = Math.floor(r1 + (rDistance * c));
		let g = Math.floor(g1 + (gDistance * c));
		let b = Math.floor(b1 + (bDistance * c));
		PALLET.push((255 << 24 | (r << 16) | (g << 8) | b) >>> 0);
	}
	
}

function generatePallet(c1){
	var distance = MAX_DISTANCE* MAX_DISTANCE;
	PALLET.forEach(c2 => {
		distance = Math.min(getDistance(c1, c2), distance);
	});

	if(!PALLET.length || (PALLET.length < MAX_COLORS && distance > THRESHOLD)){
		PALLET.push(c1);
	}
}

function farthestColors(colors){
	colors = [...new Set(colors)]
	console.log(colors.length);

	var c1, c2
	var distance = 0;

	for(var i = 0; i < colors.length; i++){
		var iColor = colors[i];
		for(var j = i + 1; j < colors.length; j++){
			var jColor = colors[j];
			let testDistance = getDistance(iColor, jColor);
			if(testDistance > distance){
				distance = testDistance;
				c1 = iColor;
				c2 = jColor;
			}
		}
	}
	
	return [c1, c2]
}

function addSplit(){
	if(PALLET.length){
		var colorMap = {}
		var randomStart = Math.floor(Math.random() * PIXEL_LIST.length)

		PALLET.forEach(p => colorMap[p] = [])
		for(var i = 0; i < 1000; i++){
			var c = buf[(i + randomStart) % PIXEL_LIST.length];
			var closest = 0;
			var distance = -1;
			PALLET.forEach(c2 => {
				var cDistance = getDistance(c, c2);
				if(cDistance < distance || distance < 0){
					distance = cDistance;
					closest = c2;
				}
			});

			colorMap[closest].push(c);
		}

		var count = -1;
		var color
		PALLET.forEach(p => {
			//colorMap[p] = [...new Set(colorMap[p])];
			if(colorMap[p].length > count){
				count = colorMap[p].length;
				color = p;
			}
		});

		PALLET = PALLET.filter(p => p != color && colorMap[p].length)
		PALLET = PALLET.concat(farthestColors(colorMap[color]));
	}else{
		PALLET = farthestColors(PIXEL_LIST.slice(0, 1000).map(pixel => buf[pixel]));
	}
}

function getDistance(c1, c2){
	const r1 = (c1 >> 16) & 0xFF; 
  	const g1 = (c1 >> 8) & 0xFF;
  	const b1 = c1 & 0xFF;
	const r2 = (c2 >> 16) & 0xFF; 
  	const g2 = (c2 >> 8) & 0xFF;
  	const b2 = c2 & 0xFF;

	return Math.pow(r1-r2, 2) + Math.pow(g1-g2, 2) +  Math.pow(b1-b2, 2)
}

function chunk(){
	let chunkWidth = Math.ceil(width / CHUNK_SIZE);
	let chunkHeight = Math.ceil(height / CHUNK_SIZE);

	for(let i = 0; i < chunkWidth; i++){
		for(let j = 0; j < chunkHeight; j++){
			setChunkColor(i, j);
		}
	}

	console.log("OUTSIZE: " + chunkWidth * chunkHeight * 4 / 8)
}

function setChunkColor(w, h){
	let palletHist = {}
	PALLET.forEach(p => palletHist[p] = 0)
	let startW = w * CHUNK_SIZE;
	let startH = h * CHUNK_SIZE;
	for(let i = startW; i < startW + CHUNK_SIZE; i++){
		for(let j = startH; j < startH + CHUNK_SIZE; j++){
			if(i < width && j < height){
				let color = buf[width * j + i];
				palletHist[color]++
			}
		}
	}

	let count = -1;
	let color
	PALLET.forEach(p => {
		if(palletHist[p] > count){
			count = palletHist[p];
			color = p;
		}
	});
	
	for(let i = startW; i < startW + CHUNK_SIZE; i++){
		for(let j = startH; j < startH + CHUNK_SIZE; j++){
			if(i < width && j < height){
				buf[width * j + i] = color;
			}
		}
	}
}

function compress(){
	let counter = 0;
	let max = 32;
	let out = [];
	let color = 0;
	let chunkWidth = Math.ceil(width / CHUNK_SIZE);
	let chunkHeight = Math.ceil(height / CHUNK_SIZE);

	for(let i = 0; i < chunkWidth; i++){
		for(let j = 0; j < chunkHeight; j++){

			let index = (j * CHUNK_SIZE * width) + (i * CHUNK_SIZE)
			if(color != buf[index] || counter == max){
				out.push(color)
				color = buf[index]
				counter = 0;
			}
			counter++;

		}
	}
	console.log(chunkWidth*chunkHeight)
	console.log(out.length)
}
</script>
</body>
</html>